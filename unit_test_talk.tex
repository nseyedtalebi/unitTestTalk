\documentclass{beamer}

\usepackage{default}
\usepackage{csquotes}[]


\begin{document}
\author{Nima Seyedtalebi}
\title{Is Unit Testing Worthwhile?}
%\logo{}
\institute{University of Kentucky}
\date{November 7, 2018}
%\subject{}
%\setbeamercovered{transparent}
%\setbeamertemplate{navigation symbols}{}

\begin{frame}[plain]
\maketitle
\end{frame}

\begin{frame}
\frametitle{Background}
\begin{itemize}
	\item The IEEE Software Engineering Body of Knowledge (SWEBOK) provides a concise definition of software testing:
	
		\blockcquote{SWEBOK}{Software testing consists of the \textit{dynamic} verification that a program provides \textit{expected} behaviors on a \textit{finite} set of test cases, suitably \textit{selected} from the usually infinite execution}
 	\item Key points:
	\begin{itemize}
 		\item Dynamic: Input and source code are not always enough to determine behavior
		\item Expected: We must be able to define expected behavior to test for it
 		\item Finite: The set of possible test cases is practically infinite, so we must choose a finite subset
 		\item Selected: Test cases can vary in usefulness considerably, so the choice is important
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Different Kinds of Testing}
\begin{itemize}
	\item Testing can be classified by target or objective
	\item Classifying by target gives three levels:
	\begin{itemize}
		\item Unit Testing: Small pieces of software testable in isolation
		\item Integration Testing: Interactions between software components
		\item System Testing: An entire system
	\end{itemize}
	\item Classifications by objective: 
	\begin{itemize}
		\item Regression testing
		\item Acceptance testing
		\item Security testing
		\item Performance testing
		\item Stress testing
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{What is Unit Testing?}
\begin{itemize}
	\item From the SWEBOK:\blockcquote{SWEBOK}{Unit testing verifies the functioning in isolation of software elements that are separately testable.}
	\begin{itemize}
 		\item What constitutes a unit? It depends on context
 		\item Developers may have differing ideas about what constitutes a unit
	\end{itemize}
	\item Usually performed by the developer of the unit or someone with programming skills and access to the source code
	\item Surveys suggest unit testing is an important testing method that sees widespread use
	\item Unit testing is sometimes conflated with other kinds of testing
	\begin{itemize}
		\item E.g. a "unit test" that relies on a database connection is not a unit test under the definition given
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Challenges in Software Testing}
\begin{itemize}
	\item Tests that are written without referring to some external specification can only suggest that the code does what the developer intended
	\item Exhaustive testing is impractical at best and impossible at worst. Consider a program like "echo" in Unix that takes a Unicode string argument:
	\begin{itemize}
		\item With Unicode 11, $137374^n$ permutations of length $n$ are possible\cite{unicodestd}
	\end{itemize}
	\item Some tests are more useful than others. How do we choose the best set of tests?
	\item How do we know if we have enough tests?
	\item How do we know if testing is effective?
	\item Testing always involves a trade-off. More tests may find more problems, but tests take time to write and maintain
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Common Test Techniques}
\begin{itemize} 
	\item Ad-hoc: Choose test inputs based on intuition and experience
	\item Boundary-value Analysis: Choose inputs close to boundaries in the input domain e.g. largest and smallest possible values for numerical datatypes
	\item Control Flow Analysis: Choose tests that follow a subset\footnote{not necessarily a proper subset} of the possible paths through the code
	\begin{itemize}
		\item Often defined in terms of coverage. A piece of code is "covered" if it executes at least once
		\item Statement, branch, and decision/condition coverage are examples 
		\item Coverage is used as a measure of test sufficiency as well
	\end{itemize}
	\item These techniques could also be considered different kinds of testing in some contexts
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Software Metrics}
\begin{itemize}
	\item Failure: An undesired behavior
	\item Fault: The cause of a failure
	\item Defect: A fault or failure
	\item Measures of the program under test:
	\begin{itemize}
		\item Fault classification, count, and density
	\end{itemize}
	\item Measures of the test set:
	\begin{itemize}
		\item Coverage, often expressed as a percentage
	\end{itemize}
	\item General software measures:
	\begin{itemize}
		\item Code size
		\item Complexity
	\end{itemize}
	\item Survey data are used to measure things that are difficult or impossible to measure objectively like perceived quality or ease of maintenance
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Arguments for Unit Testing}
\begin{itemize}
	\item Helps uncover defects early in the development process
	\item Allows developers to refactor with confidence because breaking changes will cause the tests to fail
	\item Can encourage good software design
	\begin{itemize}
		\item Unit testing requires the unit under test (UUT) to be isolated
		\item Tightly-coupled units require more effort to test
		\item Tightly-coupled units are less robust
		\item Difficulty or undue effort in testing indicates suggest code needs refactoring to reduce coupling
	\end{itemize}
	\item Tests serve as a form of documentation
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Unit Testing Considered Harmful: Arguments Against}
\begin{itemize}
	\item Unit testing does not positively affect code quality in practice
	\begin{itemize}
		\item Most tests only assess whether the code does what the developer intended
		\item Developers write lower-quality code to meet coverage-based requirements
	\end{itemize}
	\item Low-quality tests are worse than no tests at all since they must be maintained
	\item Unit tests provide a false sense of security
	\item Unit testing costs more time than it saves
	\item Integration and system testing are more effective at uncovering defects
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{What Does the Research Say?}
\begin{itemize}
	\item No correlation found yet between unit testing and code quality\cite{codeQual}
	\item No correlation found between coverage-based methods for determining test sufficiency  quality and code quality\cite{codeQual}
	\item Developers need a better understanding of what makes a unit test good\cite{unitTestSurv}
	\item Test-Driven Development (TDD), of which unit testing is an integral part, seems to measurably improve software quality\cite{TDDQual},\cite{doesTDDWork}
	\item Automated test generation is in use, but mostly used in cases where specifications are not required\cite{unitTestSurv}
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Limitations of Unit Testing}
Unit tests:
\begin{itemize}
	\item Cannot detect faults in the interaction between units or between subsystems
	\item Require some way of specifying the "correct" behavior of the unit
	\item Add to the complexity of the software under development
	\item Can contain defects
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{An Example of Several Unit Test Blunders}
\begin{itemize}
	\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{What About Test-Driven Development (TDD)?}
\begin{itemize}
	\item What is it?
	\item What are the benefits?
	\item How does TDD related to unit testing practice?
	\item How does TDD affect software quality?
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Automated Test Generation}
\begin{itemize}
	\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{There's Work to be Done!}
\begin{itemize}
	\item Talk about some open questions
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Difficulties in Research}
\begin{itemize}
	\item Make good use of "Threats to validity" section of those survey-based papers
	\item Pull out examples of challanges for papers without survey data
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Conclusions}
\begin{itemize}
	\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{References}
	\bibliographystyle{plain}
	\bibliography{unit_test_talk}
\end{frame}

\end{document}
